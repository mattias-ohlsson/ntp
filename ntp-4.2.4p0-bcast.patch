https://ntp.isc.org/bugs/show_bug.cgi?id=779
https://ntp.isc.org/bugs/show_bug.cgi?id=823

--- ntp-4.2.4p0/ntpd/ntp_peer.c.bcast	2006-12-28 13:03:31.000000000 +0100
+++ ntp-4.2.4p0/ntpd/ntp_peer.c	2007-05-22 14:37:22.000000000 +0200
@@ -696,7 +696,8 @@
 	 * as our (network) source address would be undefined and
 	 * crypto will not work without knowing the own transmit address
 	 */
-	if (interface != NULL && interface->flags & INT_WILDCARD)
+	if (interface != NULL && interface->flags & INT_WILDCARD &&
+			!(cast_flags & MDF_BCAST))
 		interface = NULL;
 
 	return interface;
--- ntp-4.2.4p0/ntpd/ntp_io.c.bcast	2007-05-22 14:29:19.000000000 +0200
+++ ntp-4.2.4p0/ntpd/ntp_io.c	2007-05-22 14:29:19.000000000 +0200
@@ -145,6 +145,8 @@
 
 volatile int disable_dynamic_updates;   /* when set to != 0 dynamic updates won't happen */
 
+static int pktinfo_status = 0;		/* is IP_PKTINFO on wildipv4 iface enabled? */
+
 #ifdef REFCLOCK
 /*
  * Refclock stuff.	We keep a chain of structures with data concerning
@@ -1530,6 +1532,18 @@
 	}
 }
 
+static void
+set_pktinfo(int flag)
+{
+	if (wildipv4 == NULL)
+		return;
+	if (setsockopt(wildipv4->fd, SOL_IP, IP_PKTINFO, &flag, sizeof (flag))) {
+		if (debug > 1)
+			printf("setsockopt(IP_PKTINFO) failed: %s\n", strerror(errno));
+	} else
+		pktinfo_status = flag;
+}
+
 /*
  * This is just a wrapper around an internal function so we can
  * make other changes as necessary later on
@@ -1935,6 +1949,7 @@
 #else
 	netsyslog(LOG_ERR, "io_setbclient: Broadcast Client disabled by build");
 #endif
+	set_pktinfo(1);
 }
 
 /*
@@ -1957,6 +1972,7 @@
 		    continue;
 		lstatus = socket_broadcast_disable(interf, &interf->sin);
 	}
+	set_pktinfo(0);
 }
 
 /*
@@ -2844,11 +2860,9 @@
 	GETSOCKNAME_SOCKLEN_TYPE fromlen;
 	int buflen;
 	register struct recvbuf *rb;
-#ifdef HAVE_TIMESTAMP
 	struct msghdr msghdr;
 	struct iovec iovec;
 	char control[TIMESTAMP_CTLMSGBUF_SIZE];	/* pick up control messages */
-#endif
 
 	/*
 	 * Get a buffer and read the frame.  If we
@@ -2859,7 +2873,7 @@
 
 	rb = get_free_recv_buffer();
 
-	if (rb == NULL || itf->ignore_packets == ISC_TRUE)
+	if (rb == NULL || (itf->ignore_packets == ISC_TRUE && !(pktinfo_status && itf == wildipv4)))
 	{
 		char buf[RX_BUFF_SIZE];
 		struct sockaddr_storage from;
@@ -2882,13 +2896,6 @@
 
 	fromlen = sizeof(struct sockaddr_storage);
 
-#ifndef HAVE_TIMESTAMP
-	rb->recv_length = recvfrom(fd,
-			  (char *)&rb->recv_space,
-			   sizeof(rb->recv_space), 0,
-			   (struct sockaddr *)&rb->recv_srcadr,
-			   &fromlen);
-#else
 	iovec.iov_base        = (void *)&rb->recv_space;
 	iovec.iov_len         = sizeof(rb->recv_space);
 	msghdr.msg_name       = (void *)&rb->recv_srcadr;
@@ -2899,7 +2906,6 @@
 	msghdr.msg_controllen = sizeof(control);
 	msghdr.msg_flags      = 0;
 	rb->recv_length       = recvmsg(fd, &msghdr, 0);
-#endif
 
 	if (rb->recv_length == 0|| (rb->recv_length == -1 && 
 	    (errno==EWOULDBLOCK
@@ -2919,6 +2925,34 @@
 		return (rb->recv_length);
 	}
 
+	if (pktinfo_status && itf->ignore_packets == ISC_TRUE && itf == wildipv4) {
+		/* check for broadcast on 255.255.255.255, exception allowed on wildipv4 */
+		struct cmsghdr *cmsg;
+		struct in_pktinfo *pktinfo = NULL;
+
+		if ((cmsg = CMSG_FIRSTHDR(&msghdr)))
+			do {
+				if (cmsg->cmsg_level == SOL_IP && cmsg->cmsg_type == IP_PKTINFO)
+					pktinfo = (struct in_pktinfo *) CMSG_DATA(cmsg);
+			} while ((cmsg = CMSG_NXTHDR(&msghdr, cmsg)));
+		if (pktinfo && pktinfo->ipi_addr.s_addr == INADDR_BROADCAST) {
+#ifdef DEBUG
+			if (debug > 3) {
+				printf("INADDR_BROADCAST\n");
+			}
+#endif
+		} else {
+#ifdef DEBUG
+			if (debug > 3)
+				printf("%s on (%lu) fd=%d from %s\n", "ignore",
+						free_recvbuffs(), fd, stoa(&rb->recv_srcadr));
+#endif
+			packets_ignored++;
+			freerecvbuf(rb);
+			return (rb->recv_length);
+		}
+	}
+
 #ifdef DEBUG
 	if (debug > 2) {
 		if(rb->recv_srcadr.ss_family == AF_INET)
@@ -2940,9 +2974,7 @@
 	 */
 	rb->dstadr = itf;
 	rb->fd = fd;
-#ifdef HAVE_TIMESTAMP
 	ts = fetch_timestamp(rb, &msghdr, ts);  /* pick up a network time stamp if possible */
-#endif
 	rb->recv_time = ts;
 	rb->receiver = receive;
 
